修改软件的艺术-构建易维护代码的9条最佳实践 PDF下载 戴维.斯科特.伯恩斯坦 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711546776
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711546776
<p>书名:修改软件的艺术-构建易维护代码的9条最佳实践</p><p>作者:戴维.斯科特.伯恩斯坦</p><p>页数:175</p><p>定价:¥55.0</p><p>出版社:人民邮电出版社</p><p>出版日期:2017-10-01</p><p>ISBN:9787115467768</p><p><h2>本书特色</h2></p>[<p>
《修改软件的艺术 构建易维护代码的9条*实践》会帮你降低构建与维护软件的成本。如果你是软件开发者，将学到一套实践方法以构建易修改的代码，因为在应用当中代码经常需要修改。对于和软件开发者合作的管理者来说，本书会向你展示为何引入这9个基本的实践方法，会使你的团队更加有效地交付软件而不至于让软件演变成遗留代码。
                                        </p>]<p><h2>内容简介</h2></p>[<p>遗留代码是指因为种种原因格外难以修正、改进以及使用的代码，这样的代码有很多，每天我们都会因为遗留代码而损失时间、金钱和机遇，软件产业通常轻视可维护性，所以到*后企业花在维护代码上的成本比一开始编写代码的成本还高。本书针对这一现状，总结了9条构建易维护代码、解决遗留代码的zui佳原则，是敏捷开发的具体实战指南。
本书不仅仅是关于如何构建更好的软件，更是关于如何构建更好的软件产业。书中囊括了作者身为专业开发者三十年所学的精华。如果你想要优化软件交付流程，但是感觉到裹足不前、无能为力，那么这本书正适合你。 </p>]<p><h2>作者简介</h2></p>[<p>David Scott Bernstein 敏捷教练，曾为IBM、微软、Yahoo等企业提供敏捷实践指导。他的公司To Be Agile （tobeagile.com）指导团队进行测试先行、结对编程以及重构等极限编程实践。</p>]<p><h2>目录</h2></p>
    **部分 遗留代码危机
第 1 章 有些事情不对劲    2
1.1 什么是遗留代码    3
1.2 顺流直下    4
1.3 孤注一掷    6
1.4 为什么瀑布模型不管用    7
1.4.1 食谱与配方    7
1.4.2 开发和测试分离    8
1.5 当“流程”变成“体力劳动”    8
1.6 坚如磐石的管理    9
1.7 此处有龙    10
1.8 评估未知    11
1.9 一个充满外行人的产业    12
1.10 回顾    13
第 2 章 逃出混乱    14
2.1 混乱报告    14
2.1.1 成功的    15
2.1.2 遇到困难的    15
2.1.3 失败的（有缺陷的）    15
2.2 驳斥斯坦迪什咨询集团    16
2.3 项目为何会失败    17
2.4 失败的代价    21
2.4.1 这里十几亿，那里十几亿    21
2.4.2 不同的研究，同样的危机    22
2.5 总结    23
第 3 章 聪明人，新想法    25
3.1 走进敏捷    25
3.2 小即是好    26
3.3 实现敏捷    27
3.4 艺术与技能的平衡    28
3.5 敏捷跨越鸿沟    29
3.6 追求技术卓越    30
3.7 总结    31
第二部分 延续软件生命（和价值）的9种实践方法
第 4 章 9个实践    34
4.1 专家知道什么    35
4.2 守-破-离    36
4.3 首要原则    37
4.4 关于原则    38
4.5 关于实践    38
4.6 原则指导实践    39
4.7 未雨绸缪还是随机应变    40
4.8 定义软件中的“好”    40
4.9 为什么是9个实践    42
4.10 总结    43
第 5 章 实践1：在问如何做之前先问做什么、为什么做、给谁做    44
5.1 不要说如何    44
5.2 将“如何”变为“什么”    45
5.3 要有一个产品负责人    46
5.4 故事描述了做什么、为什么做、给谁做    48
5.5 为验收测试设立明确标准    50
5.6 自动化验收标准    50
5.7 让我们付诸实践    51
5.7.1 产品负责人的7个策略    51
5.7.2 编写出更好用户故事的7个策略    52
5.8 总结    53
第6 章 实践2：小批次构建    55
6.1 更小的谎言    56
6.2 学会变通    56
6.3 控制发布节奏    58
6.4 越小越好    59
6.5 分而治之    60
6.6 更短的反馈回路    62
6.7 提高构建速度    63
6.8 对反馈做出响应    64
6.9 建立待办列表    65
6.10 把用户故事拆分为任务    66
6.11 跳出时间盒子思考    66
6.12 范围控制    67
6.13 让我们付诸实践    69
6.13.1 度量软件开发的7个策略    69
6.13.2 分割用户故事的7个策略    70
6.14 总结    71
第7 章 实践3：持续集成    72
7.1 建立项目的心跳    73
7.2 理解完成、完整完成和完美完成的区别    73
7.3 实践持续部署    74
7.4 自动化构建    75
7.5 尽早集成，频繁集成    76
7.6 迈出**步    76
7.7 付诸实践    77
7.7.1 构建敏捷设施的7个策略    77
7.7.2 消除风险的7个策略    79
7.8 总结    80
第8 章 实践4：协作    81
8.1 极限编程    82
8.2 沟通与协作    83
8.3 结对编程    84
8.3.1 结对的好处    85
8.3.2 如何结对编程    86
8.3.3 和谁结对    87
8.4 伙伴编程    88
8.5 穿刺，群战，围攻    89
8.5.1 穿刺    89
8.5.2 群战    89
8.5.3 围攻    89
8.6 在时间盒子中对未知进行调研    90
8.7 定期代码审查和回顾会议    91
8.8 加强学习和知识分享    92
8.9 诲人不倦且不耻下问    92
8.10 让我们付诸实践    93
8.10.1 结对编程的7个策略    93
8.10.2 高效回顾会议的7个策略    94
8.11 总结    95
第9 章 实践5：编写整洁的代码    97
9.1 高质量的代码是内聚的    98
9.2 高质量的代码是松散耦合的    99
9.3 高质量的代码是封装良好的    100
9.4 高质量的代码是自主的    102
9.5 高质量的代码是没有冗余的    104
9.6 让代码特质指导我们    105
9.7 今天的代码质量提高会为将来带来速度的提升    106
9.8 让我们付诸实践    107
9.8.1 提高代码质量的7个策略    107
9.8.2 编写可维护代码的7个策略    108
9.9 总结    109
第10 章 实践6：测试先行    110
10.1 测试的种类    111
10.1.1 验收测试 = 客户测试    111
10.1.2 单元测试 = 开发者测试    111
10.1.3 其他测试 = 质量保证测试    112
10.2 质量保证    112
10.2.1 测试驱动开发不能取代质量保证    113
10.2.2 单元测试不是万能的    113
10.3 编写优质测试    114
10.3.1 这不是测试    115
10.3.2 以行为作为单元    115
10.4 TDD可以提供迅速的反馈    116
10.5 TDD可以为重构提供支持    116
10.6 编写可测试的代码    117
10.7 TDD也会失败    118
10.8 如何将TDD引入团队    119
10.9 成为测试感染者    119
10.10 让我们付诸实践    120
10.10.1 进行优质验收测试的7个策略    120
10.10.2 进行优秀单元测试的7个策略    121
10.11 总结    122
第11 章 实践7：用测试描述行为    123
11.1 红条、绿条、重构    124
11.2 一个用测试先行来描述行为的实例    125
11.2.1 编写测试    125
11.2.2 存根代码    126
11.2.3 实现行为    127
11.3 引入限制条件    128
11.3.1 编写测试和代码存根    129
11.3.2 实现行为    129
11.4 我们创建了什么    130
11.5 测试就是标准    132
11.6 测试需要完整    133
11.7 让测试独一无二    134
11.8 用测试来覆盖代码    134
11.9 bug是缺失的测试    135
11.10 用模拟对象来测试工作流    135
11.11 建立防护网    136
11.12 让我们付诸实践    136
11.12.1 使用测试作为标准的7个策略    136
11.12.2 修复bug的7个策略    137
11.13 总结    139
第12 章 实践8：*后实现设计    140
12.1 可变性的阻碍    140
12.2 可持续性开发    142
12.3 编码与清理    143
12.4 软件被阅读的次数比编写次数多    143
12.5 意图导向编程    144
12.6 降低圈复杂度    145
12.7 将创建和使用分离    146
12.8 演化式设计    147
12.9 让我们付诸实践    147
12.9.1 进行演化式设计的7个策略    148
12.9.2 清理代码的7个策略    149
12.10 总结    150
第13 章 实践9：重构遗留代码    151
13.1 投资还是借贷    152
13.2 变成“铁公鸡”    153
13.3 当代码需要修改时    153
13.3.1 对已有代码添加测试    154
13.3.2 通过重构糟糕代码来培养良好习惯    154
13.3.3 推迟那些不可避免的    155
13.4 重构技巧    155
13.4.1 图钉测试    155
13.4.2 依赖注入    156
13.4.3 系统扼杀    156
13.4.4 抽象分支    156
13.5 以支持修改为目的重构    157
13.6 以开闭原则为目的重构    157
13.7 以提高可修改性为目的重构    158
13.8 第二次做好    158
13.9 让我们付诸实践    159
13.9.1 助你正确重构代码的7个策略    159
13.9.2 决定何时进行重构的7个策略    161
13.10 总结    162
第14 章 从遗留代码中学习    163
14.1 更好，更快，更廉价    164
14.2 不在不需要的事情上花钱    166
14.3 循规蹈矩    167
14.4 提升整个软件行业    168
14.5 超越敏捷    169
14.6 将理解具象化    170
14.7 成长的勇气    171
参考文献    174
