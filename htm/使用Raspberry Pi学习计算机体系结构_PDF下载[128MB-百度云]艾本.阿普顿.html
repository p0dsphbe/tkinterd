使用Raspberry Pi学习计算机体系结构 PDF下载 艾本.阿普顿 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#730248717
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#730248717
<p>书名:使用Raspberry Pi学习计算机体系结构</p><p>作者:艾本.阿普顿</p><p>页数:385</p><p>定价:¥79.8</p><p>出版社:清华大学出版社</p><p>出版日期:2018-01-01</p><p>ISBN:9787302487173</p><p><h2>本书特色</h2></p>[<p>
《使用Raspberry Pi学习计算机体系结构》能帮助读者
■　了解Raspberry Pi每个部分的设计目的
■　理解不同组件之间的交互方式
■　深入了解系统设计的完整过程
■　学习程序设计原理
■　观察硬件和操作系统之间的相互作用
■　深入研究ARM芯片背后的机制
■　比较和对照不同的芯片，从ARM到Intel
                                        </p>]<p><h2>内容简介</h2></p>[<p>Raspberry Pi的诞生，深受20世纪80年代价格相对低廉的高度可编程计算机(以及它们对英国高新技术产生的影响)的启发，它激励新一代程序设计师并为他们提供准入平台。经济成本和技术门槛的可接受性，使得Raspberry Pi成为学习计算机工作原理的理想工具。《使用Raspberry Pi学习计算机体系结构》将会是你整个Raspberry Pi内幕发现之旅的私人指南，也将成为你学习由Raspberry Pi完美诠释的知识库的专业级教练。作者Eben Upton和Jeff Duntemann是理想的导师：作为Raspberry Pi的共同创始人，Upton展现出他的深刻洞察力；Dunteman则将复杂的技术知识凝练为易于理解的解释。以Raspberry Pi这块信用卡般大小的计算机(正在革新编程世界)的体系结构为基础，Upton和Duntemann共同提供了隐藏在所有计算机背后的技术的专业级指导。　　《使用Raspberry Pi学习计算机体系结构》按部就班地讲解每个组件，包括组件能做什么、为何需要它、该组件与其他组件的关系，以及组件创建过程中设计者面临的选择等。从内存、存储器和处理器，到以太网、相机和音频。Upton和Duntemann相互合作，确保读者扎实理解Raspberry Pi的内部结构及其整体上与计算背后的技术之间的关系。 </p>]<p><h2>作者简介</h2></p>[<p>Eben Upton是Raspberry Pi基金会的创始人，也是该基金会旗下的贸易部门Raspberry Pi(贸易)有限公司的CEO，他与Gareth Halfacree合著了Raspberry Pi User Guide一书。Eben早年创办了两家成功的移动游戏和中间件公司(Ideaworks 3d 和Podfun)，还曾担任剑桥大学圣约翰学院计算机科学的教学主管，并和他的父亲Clive Upton教授一起编写了牛津诗韵词典(Oxford Rhyming Dictionary)。Eben在剑桥大学获得了物理学和工程学学士学位以及计算机科学博士学位，还获得了工商管理硕士学位。<br/>Jeff Duntemann从1974年就开始出版各种技术类和科幻类出版物。它是Xerox公司的程序师，同时还担任Ziff-Davis出版社和Borland国际软件公司的技术编辑。他编辑发行了两份程序师杂志，在其名下有20本技术性书籍，包括最畅销的Assembly Language Step By Step一书。在Dr. Dobb’s Journal杂志上，Jeff连续四年撰写“Structured Programming”专栏，并在很多杂志上发表了大量技术性文章。1989年，Jeff和他的作家伙伴Keith Weiskamp发起成立了Coriolis Group，到1998年Coriolis Group已经成为美国亚利桑那州最大的图书出版商。Jeff对“强”人工智能表现出持久的兴趣，他的绝大部分科幻著作(包括The Cunning Blood和Ten Gentle Opportunities两本小说)都在探寻强人工智能的因果逻辑。Jeff的其他兴趣包括望远镜和风筝，他还是一位电子学和无线电业余爱好者(呼号K7JPD)。在过去的40年里，Jeff一直和妻子Carol居住在美国亚利桑那州的菲尼克斯市，陪伴他们的还有四条卷毛比雄犬。Eben Upton是Raspberry Pi基金会的创始人，也是该基金会旗下的贸易部门Raspberry Pi(贸易)有限公司的CEO，他与Gareth Halfacree合著了Raspberry Pi User Guide一书。Eben早年创办了两家成功的移动游戏和中间件公司(Ideaworks 3d 和Podfun)，还曾担任剑桥大学圣约翰学院计算机科学的教学主管，并和他的父亲Clive Upton教授一起编写了牛津诗韵词典(Oxford Rhyming Dictionary)。Eben在剑桥大学获得了物理学和工程学学士学位以及计算机科学博士学位，还获得了工商管理硕士学位。<br/>Jeff Duntemann从1974年就开始出版各种技术类和科幻类出版物。它是Xerox公司的程序师，同时还担任Ziff-Davis出版社和Borland国际软件公司的技术编辑。他编辑发行了两份程序师杂志，在其名下有20本技术性书籍，包括最畅销的Assembly Language Step By Step一书。在Dr. Dobb’s Journal杂志上，Jeff连续四年撰写“Structured Programming”专栏，并在很多杂志上发表了大量技术性文章。1989年，Jeff和他的作家伙伴Keith Weiskamp发起成立了Coriolis Group，到1998年Coriolis Group已经成为美国亚利桑那州最大的图书出版商。Jeff对“强”人工智能表现出持久的兴趣，他的绝大部分科幻著作(包括The Cunning Blood和Ten Gentle Opportunities两本小说)都在探寻强人工智能的因果逻辑。Jeff的其他兴趣包括望远镜和风筝，他还是一位电子学和无线电业余爱好者(呼号K7JPD)。在过去的40年里，Jeff一直和妻子Carol居住在美国亚利桑那州的菲尼克斯市，陪伴他们的还有四条卷毛比雄犬。<br/>Ralph Roberts是一名受过嘉奖的越战老兵，在阿波罗登月工程期间供职于NASA。自从1979年在Creative Computing杂志上发表第一篇文章开始，Roberts就一直从事计算机和软件方面的写作。Roberts为国家出版商撰写了超过100本书籍，以及上千篇文章和短篇小说。总而言之，他已经发售了超过2000万字的专业内容。Roberts的最佳畅销书包括美国第一本关于计算机病毒(美国国家电台由此诞生了多部相关电影)的书籍，还有过去21年里反复印刷的一本烹饪食谱—— Classic Cooking with Coca-Cola，目前已经售出了50万本。<br/>Tim Mamtora是博通有限公司IC设计部门的总工程师，目前是美国GPU硬件团队的技术带头人。他在移动计算机图形学方面从事了近七年的工作，此前为模拟电视和传统DSP<br/><br/> 硬件开发内部IP。Tim 拥有剑桥大学工程学硕士学位，其中第三年在马萨诸塞州技术学院度过，在那里激发了Tim 对数字硬件设计的兴趣。他对推进工程充满激情，并专门花费时间在剑桥大学指导学生，他还在母校发表工程学机遇方面的演讲。工作之余，Tim 喜欢各类体育运动、摄影以及游览世界。<br/>Ben Everard 是一位作家，也是一位播客。平时为Linux 编写修补代码，还喜欢摆弄机<br/>器人。本书是Everard的第二部著作，他还撰写了Learning Python with Raspberry Pi一书<br/>(Wiley 出版社，2014)。可以在推特@ben_everard上找到他。</p>]<p><h2>目录</h2></p>
    目录
 
第1章 计算机漫谈 1
1.1 日益缤彩纷呈的Raspberry 1
1.2 片上系统 4
1.3 一台令人激动的信用卡般大小的计算机 5
1.4 Raspberry Pi的功能 6
1.5 Raspberry Pi板 7
1.5.1 GPIO引脚 7
1.5.2 状态LED 9
1.5.3 USB插口 10
1.5.4 以太网连接 10
1.5.5 音频输出 11
1.5.6 复合视频 12
1.5.7 CSI摄像头模块连接器 13
1.5.8 HDMI 13
1.5.9 micro USB电源 14
1.5.10 存储卡 14
1.5.11 DSI显示连接 15
1.5.12 装配孔 15
1.5.13 芯片 16
1.6 未来 16
第2章计算概述 19
2.1 计算机与烹饪 20
2.1.1 佐料与数据 20
2.1.2 基本操作 21
2.2 按计划执行的盒子 22
2.2.1 执行和知晓 22
2.2.2 程序就是数据 23
2.2.3 存储器 24
2.2.4 寄存器 25
2.2.5 系统总线 26
2.2.6 指令集 26
2.3 电平、数字及其表示 27
2.3.1 二进制：以1和0表示 27
2.3.2 手指的局限性 29
2.3.3 数量、编号和0 29
2.3.4 用于二进制速记的十六进制 30
2.3.5 执行二进制和十六进制运算 31
2.4 操作系统：幕后老板 33
2.4.1 操作系统的功能 33
2.4.2 向内核致敬 34
2.4.3 多核 34
第3章电子存储器35 
3.1 存储器先于计算机而存在 35 
3.2 旋转磁存储器(Rotating Magnetic Memory)  363.3 磁芯存储器 37 
3.3.1 磁芯存储器的工作过程38 
3.3.2 存储器访问时间39 
3.4 静态随机访问存储器(SRAM)  40 
3.5 地址线和数据线 41 
3.6 由存储器芯片构建存储器系统42 
3.7 动态随机访问存储器(DRAM)  45 
3.7.1 DRAM的工作原理 45 
3.7.2 同步DRAM和异步DRAM47 
3.7.3 SDRAM列、行、Bank、Rank和DIMM 49 
3.7.4 DDR、DDR2、DDR3和DDR4 SDRAM50 
3.7.5 纠错码存储器53 
3.8 Raspberry Pi的存储器系统54 
3.8.1节能性54 
3.8.2球栅阵列封装55 
3.9 缓存 55 
3.9.1访问的局部性56 
3.9.2缓存层级56 
3.9.3缓存行和缓存映射57 
3.9.4直接映射59 
3.9.5相联映射61 
3.9.6组相联高速缓存62 
3.9.7回写缓存到存储器63 
3.10 虚拟存储器 64 
3.10.1虚拟存储器概览64 
3.10.2虚拟存储器到物理存储器的映射65 
3.10.3 深入了解存储器管理单元66 
3.10.4 多级页表和TLB69 
3.10.5 Raspberry Pi的交换问题70 
3.10.6 Raspberry Pi虚拟存储器70 
第4章ARM处理器与片上系统73 
4.1 急速缩小的CPU  73 
4.1.1微处理器74 
4.1.2晶体管预算75 
4.2 数字逻辑基础 75 
4.2.1逻辑门75 
4.2.2触发器和时序逻辑76 
4.3 CPU内部78 
4.3.1分支与标志79 
4.3.2系统栈80 
4.3.3系统时钟和执行时间82 
4.3.4流水线技术83 
4.3.5流水线技术详解84 
4.3.6深入流水线以及流水线阻塞86 
4.3.7 ARM11 中的流水线88 
4.3.8 超标量执行89 
4.3.9 基于SIMD的更多并行机制90 
4.3.10 字节序92 
4.4 CPU再认识：CISC与RISC  93 
4.4.1 RISC的历史95 
4.4.2 扩展的寄存器文件95 
4.4.3 加载/存储架构 96 
4.4.4 正交的机器指令96 
4.4.5 独立的指令和数据高速缓存97 
4.5 源于艾康的ARM  97 
4.5.1微架构、内核及家族98 
4.5.2 出售设计许可而非成品芯片98 
4.6 ARM11 
99 
4.6.1 ARM指令集99 
4.6.2 处理器模式102 
4.6.3 模式和寄存器103 
4.6.4 快速中断107 
4.6.5 软件中断108 
4.6.6 中断优先级108 
4.6.7 条件指令执行109 
4.7 协处理器  111 
4.7.1 ARM协处理器接口112 
4.7.2 系统控制协处理器113 
4.7.3 向量浮点协处理器113 
4.7.4 仿真协处理器114 
4.8 ARM Cortex  114 
4.8.1 多发和乱序执行115 
4.8.2 Thumb 2 115 
4.8.3 Thumb EE  115 
4.8.4 big.LITTLE 116 
4.8.5 NEON SIMD协处理器 116 
4.8.6 ARMv8和64位计算117 
4.9 片上系统 118 
4.9.1 博通BCM2835 SoC  118 
4.9.2 第二代和第三代博通SoC 设备119 
4.9.3 VLSI芯片原理119 
4.9.4 流程、制程工艺和掩膜120 
4.9.5 IP：单元、宏单元、内核120 
4.9.6 硬IP和软IP121 
4.9.7 平面规划、布局和布线121 
4.9.8 片上通信的标准：AMBA 122 
第5章程序设计 125 
5.1 程序设计概述 125 
5.1.1 软件开发过程126 
5.1.2 瀑布、螺旋与敏捷128 
5.1.3 二进制程序设计130 
5.1.4 汇编语言和助记符131 
5.1.5 高级语言132 
5.1.6 花样泛滥的后BASIC 时代134 
5.1.7 程序设计术语135 
5.2 本地代码编译器的工作原理 137 
5.2.1 预处理138 
5.2.2 词法分析138 
5.2.3 语义分析139 
5.2.4 生成中间代码139 
5.2.5 优化139 
5.2.6 生成目标代码139 
5.2.7 C编译：一个具体示例140 
5.2.8 链接目标代码文件到可执行文件145 
5.3 纯文本解释程序 146 
5.4 字节码解释语言 148 
5.4.1 p-code 148 
5.4.2 Java 149 
5.4.3 即时编译(JIT) 150 
5.4.4 Java之外的字节码和JIT 编译152 
5.4.5 Android 、Java和Dalvik 152 
5.5 数据构建块 152 
5.5.1 标识符、关键字、符号和操作符153 
5.5.2 数值、文本和命名常量153 
5.5.3 变量、表达式和赋值154 
5.5.4 类型和类型定义154 
5.5.5 静态和动态类型156 
5.5.6 补码和IEEE 754 157 
5.6 代码构建块 159 
5.6.1 控制语句和复合语句159 
5.6.2 if/then/else 159 
5.6.3 switch和case 161 
5.6.4 repeat循环162 
5.6.5 while循环163 
5.6.6 for循环164 
5.6.7 break和continue语句166 
5.6.8 函数166 
5.6.9 局部性和作用域168 
5.7 面向对象程序设计 170 
5.7.1 封装172 
5.7.2 继承174 
5.7.3 多态176 
5.7.4 OOP小结 178 
5.8 GNU编译器工具集概览178 
5.8.1 作为编译器和生成工具的gcc179 
5.8.2 使用Linux make 181 
第6章非易失性存储器185 
6.1 打孔卡和磁带 186 
6.1.1 打孔卡186 
6.1.2 磁带数据存储器186 
6.1.3 磁存储器的黎明188 
6.2 磁记录和编码方案 189 
6.2.1 磁通跃迁190 
6.2.2 垂直记录191 
6.3 磁盘存储器 192 
6.3.1 柱面、磁轨和扇区193 
6.3.2 低级格式化194 
6.3.3 接口和控制器195 
6.3.4 软盘驱动器197 
6.4 分区和文件系统 198 
6.4.1 主分区和扩展分区198 
6.4.2 文件系统和高级格式化199 
6.4.3 未来：GUID分区表 (GPT) 200 
6.4.4 Raspberry Pi SD卡的分区201 
6.5 光盘 202 
6.5.1 源自CD的格式203 
6.5.2 源自DVD的格式204 
6.6 虚拟硬盘 205 
6.7 Flash存储器206 
6.7.1 ROM、PROM和 EPROM 206 
6.7.2 Flash与EEPROM 207 
6.7.3 单级与多级存储209 
6.7.4 NOR Flash与NAND Flash 210 
6.7.5 损耗平衡及Flash转换层213 
6.7.6 碎片回收和TRIM 214 
6.7.7 SD卡 215 
6.7.8 eMMC216 
6.7.9 非易失性存储器的未来217 
第7章有线和无线以太网219 
7.1 网络互连OSI参考模型220 
7.1.1 应用层222 
7.1.2 表示层222 
7.1.3 会话层223 
7.1.4 传输层223 
7.1.5 网络层224 
7.1.6 数据链路层226 
7.1.7 物理层226 
7.2 以太网  227 
7.2.1 粗缆以太网和细缆以太网227 
7.2.2 以太网的基本构想227 
7.2.3 冲突检测和规避228 
7.2.4 以太网编码系统229
7.2.5 PAM-5 编码232
7.2.6 10BASE-T和双绞线233 
7.2.7 从总线拓扑结构到星型拓扑结构234 
7.2.8 交换以太网235 
7.3 路由器和互联网 237  
7.3.1 名称与地址237 
7.3.2 IP地址和TCP端口238
7.3.3 本地IP地址和DHCP 240 
7.3.4 网络地址转换242 
7.4 Wi-Fi 
243 
7.4.1 标准中的标准244 
7.4.2 面对现实世界245 
7.4.3 正在使用的Wi-Fi 设备 248 
7.4.4 基础设施网络与Ad Hoc 网络249 
7.4.5 Wi-Fi 分布式介质访问 250 
7.4.6 载波监听和隐藏结点问题251 
7.4.7 分片253 
7.4.8 调幅、调相和QAM 253 
7.4.9 扩频技术256 
7.4.10 Wi-Fi 调制和编码细节256 
7.4.11 Wi-Fi 连接的实现原理259 
7.4.12 Wi-Fi 安全性 260 
7.4.13 Raspberry Pi上的Wi-Fi 261 
7.4.14 更多的网络263 
第8章
操作系统   265
8.1 操作系统简介  266
8.1.1 操作系统的历史 267
8.1.2 操作系统基础 270
8.2 内核：操作系统的核心主导者  274
8.2.1 操作系统控制 276
8.2.2 模式 276
8.2.3 存储器管理 277
8.2.4 虚拟存储器 278
8.2.5 多任务处理 278
8.2.6 磁盘访问和文件系统 279
8.2.7 设备驱动程序 279
8.3 操作系统的使能器和助手  279
8.3.1 唤醒操作系统 280
8.3.2 固件 283
8.4 Raspberry Pi上的操作系统  283
8.4.1 NOOBS 284
8.4.2 第三方操作系统 285
8.4.3 其他可用的操作系统 285
第9章 视频编解码器和视频压缩  287
9.1 **个视频编解码器   288
9.1.1 利用眼睛  288
9.1.2 利用数据  290
9.1.3 理解频率变换  293
9.1.4 使用无损编码技术  297
9.2 时移世易  298
9.2.1 MPEG的*新标准  299
9.2.2 H.265     302
9.3 运动搜索   302
9.3.1 视频质量  304
9.3.2 处理能力  305
第10章 3D图形307 
10.1 3D图形简史307 
10.1.1 图形用户界面(Graphical User Interface，GUI) 308 
10.1.2 视频游戏中的3D图形310 
10.1.3 个人计算和显卡311 
10.1.4 两个竞争标准312 
10.2 OpenGL图形管线 314 
10.2.1 几何规范和属性315 
10.2.2 几何变换317 
10.2.3 光照和材质320 
10.2.4 图元组装和光栅化322 
10.2.5 像素处理(片段着色)324 
10.2.6 纹理326 
10.3 现代图形硬件 328 
10.3.1 瓦片渲染329 
10.3.2 几何拒绝330 
10.3.3 着色332 
10.3.4 缓存333 
10.3.5 Raspberry Pi GPU 334 
10.4 Open VG  336 
10.5 通用GPU  338 
10.5.1 异构体系结构338 
10.5.2 OpenCL 339 
第11章音频 341 
11.1 现在能听到我的声音吗？341 
11.1.1 MIDI342 
11.1.2 声卡342 
11.2 模拟与数字343 
11.3 声音和信号处理344 
11.3.1 编辑344 
11.3.2 压缩345 
11.3.3 使用特效录制345 
11.3.4 编码和解码通信信息346 
11.4 1位DAC 347 
11.5 I2S 
349 
11.6 Raspberry Pi声音输入/输出350 
11.6.1 音频输出插孔350 
11.6.2 HDMI350 
11.7 Raspberry Pi的声音351 
11.7.1 Raspberry Pi板载声音351 
11.7.2 处理Raspberry Pi的声音351 
第12章 输入/输出359 
12.1 输入/输出简介 359 
12.2 I/O使能器 362 
12.2.1 通用串行总线363 
12.2.2 USB有源集线器365 
12.2.3 以太网367 
12.2.4 通用异步收发器368 
12.2.5 小型计算机系统接口368 
12.2.6 PATA 369 
12.2.7 SATA 369 
12.2.8 RS-232串口 370 
12.2.9 HDMI 370 
12.2.10 I2S 371 
12.2.11 I2C 371 
12.2.12 Raspberry Pi显示器、摄像头接口和JTAG 372 
12.3 Raspberry Pi GPIO  373 
12.3.1 GPIO概述以及博通SoC 373 
12.3.2 接触GPIO 374 
12.3.3 可编程GPIO 380 
12.3.4 可选模式385 
12.3.5 GPIO实验的简单方法 385
