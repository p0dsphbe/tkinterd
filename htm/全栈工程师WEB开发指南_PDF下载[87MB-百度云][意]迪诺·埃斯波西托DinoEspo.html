全栈工程师WEB开发指南 PDF下载 [意]迪诺·埃斯波西托DinoEspo 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711549745
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711549745
<p>书名:全栈工程师WEB开发指南</p><p>作者:[意]迪诺·埃斯波西托Dino Espo</p><p>页数:324</p><p>定价:¥79.0</p><p>出版社:人民邮电出版社</p><p>出版日期:2018-09-01</p><p>ISBN:9787115497451</p><p><h2>本书特色</h2></p>[<p>
本书通过介绍一种实用的、问题驱动的，关注用户的方法，介绍了规划、设计和构建动态的Web强有力的方法，给出了目前进行Web开发的一套有效解决方案。本书引导读者选择和实现特定的技术，阐释了重要的用户体验主题，并探讨了对移动友好的技术和反应式设计技术等内容。除此之外，本书还介绍了ASP.NET MVC、SignalR、Bootstrap、AJAX、JSON和JQuery等技术的相关内容。
通过阅读本书，读者将学到如何从DDD方法以及现代的UX设计方法中获益，进而能够快速构建出解决当前问题并且有出色用户体验的Web解决方案。
                                        </p>]<p><h2>内容简介</h2></p>[<p>结合DDD方法及现代UX设计方法，讲述一种实用的、问题驱动的、关注用户的方法
引导读者掌握Web架构、Web设计和Web用户体验的有效新方法
帮助读者有效运用“用户体验优先”的现代设计方法 </p>]<p><h2>作者简介</h2></p>[<p>迪诺·埃斯波西托（Dino Esposito）是Crionet（一家为欧洲各地体育赛事提供Web移动解决方案的公司）的CTO和联合创始人。他长期从事培训和顾问工作，曾11次荣获微软MVP殊荣，并著有《Microsoft. NET企业级应用架构设计（第2版）》和《企业级移动方案架构设计》。他还经常在行业活动中发表演讲，其中包括Microsoft TechEd以及SDD、BASTA和Devweek等欧洲活动。</p>]<p><h2>目录</h2></p>
    第 一部分  理解业务领域

第　1章 实施全面的领域分析　3
1.1　领域驱动设计前来解困　3
1.1.1　领域驱动设计　3
1.1.2　消除DDD的常见误解　4
1.2　通用语言　5
1.2.1　创建领域特定术语的词汇表　5
1.2.2　使业务和代码保持同步　7
1.3　限界上下文　8
1.3.1　发现限界上下文　8
1.3.2　实现限界上下文　9
1.4　上下文映射　11
1.5　事件风暴　12
1.5.1　拥有无尽的建模空间　13
1.5.2　找出领域中的事件　13
1.5.3　引导讨论　13
1.6　小结　13
第　2章 选择支撑架构　15
2.1　关于业务逻辑的一切　15
2.1.1　研究应用程序逻辑　15
2.1.2　研究领域逻辑　16
2.1.3　探究业务逻辑的模式　17
2.2　使用单个模型　19
2.2.1　探究面向对象领域模型的元素　19
2.2.2　把业务规则放进去　20
2.2.3　发现聚合　22
2.2.4　探究领域服务的角色　23
2.3　实现命令查询分离　25
2.3.1　应用命令查询分离原则　26
2.3.2　实现CQRS　28
2.4　基于消息的方案　30
2.4.1　专属基础设施　30
2.4.2　介绍事件溯源　33
2.5　小结　35
第3章　用户体验驱动设计　36
3.1　为什么自上而下方案比自下而上方案更优　36
3.1.1　自下而上方案的基础　37
3.1.2　规划自上而下方案　39
3.2　从架构的角度来看用户体验　40
3.2.1　用户体验不是用户界面　40
3.2.2　三步解释用户体验驱动设计　42
3.3　为什么用户体验驱动设计几乎有利于每个人　46
3.4　小结　47
第4章　Web解决方案的架构选项　49
4.1　评估可用的Web解决方案　49
4.1.1　决定*佳框架　49
4.1.2　规划解决方案　50
4.2　研究ASP.NET Core 1.0的角色　51
4.2.1　把ASP.NET看作起点　51
4.2.2　研究ASP.NET Core 1.0里的架构依赖　52
4.2.3　探究选择ASP.NET Core 1.0的原因　53
4.3　决定是否应该使用ASP.NET Web Forms　55
4.3.1　研究一个常见的场景　55
4.3.2　ASP.NET Web Forms初探　55
4.3.3　Web Forms仍有好的一面　56
4.3.4　为什么应该远离Web Forms　56
4.4　决定是否应该使用ASP.NET MVC　57
4.4.1　ASP.NET MVC初探　58
4.4.2　ASP.NET MVC的优点　58
4.4.3　ASP.NET MVC的弱点　59
4.5　研究ASP.NET Web API的角色　59
4.5.1　WCF转到Web API　60
4.5.2　比较ASP.NET Web API和ASP.NET MVC　60
4.5.3　聊聊REST　62
4.5.4　在ASP.NET Core 1.0里使用Web API　62
4.6　单页应用程序　63
4.6.1　构建SPA　64
4.6.2　混合SPA　64
4.6.3　SPA的弱点　64
4.7　小结　65
第5章　分层架构　66
5.1　超越经典的三层系统　66
5.1.1　目前使用的三层架构　67
5.1.2　灰色地带　67
5.2　表现层　68
5.2.1　用户体验　68
5.2.2　输入模型　69
5.2.3　视图模型　69
5.3　应用程序层　70
5.3.1　系统后端的入口点　70
5.3.2　业务流程的编排　71
5.4　领域层　71
5.4.1　神秘的领域模型　72
5.4.2　同样神秘的领域服务概念　72
5.4.3　更务实的领域建模观点　73
5.5　基础设施层　73
5.5.1　当前状态存储　73
5.5.2　事件存储　74
5.5.3　缓存层　75
5.5.4　外部服务　75
5.6　小结　75

第二部分　实现常见功能

第6章　ASP.NET的现状　79
6.1　Web的风格　79
6.1.1　Web原本可以不同　79
6.1.2　经典Web是赢家　80
6.2　ASP.NET是功能完整的　80
6.2.1　不必添加更多功能　81
6.2.2　它的潜能得到充分挖掘，还是说这个软件已遭废弃　81
6.3　ASP.NET Core 1.0没有新的功能　81
6.3.1　这是关于新的运行时　82
6.3.2　这是关于业务模型　82
6.3.3　这是关于开发模型　82
6.4　ASP.NET的现状是什么　82
第7章　ASP.NET Core 1.0的来龙去脉及技术细节　84
7.1　ASP.NET Core的背景　84
7.1.1　大内存占用的代价　85
7.1.2　把云重新看作杀手锏　85
7.1.3　不同的编程模型的必要性　85
7.1.4　日常工作的影响　86
7.2　ASP.NET Core运行时概览　86
7.2.1　DNX托管环境　87
7.2.2　在DNX中托管Web应用程序　88
7.2.3　ASP.NET Core HTTP通道　89
7.3　ASP.NET开发者的ASP.NET Core使用指南　90
7.3.1　创建一个新的项目　91
7.3.2　应用程序启动　94
7.3.3　应用程序设置　96
7.3.4　验证　98
7.3.5　Web编程的其他方面　99
7.4　小结　101
第8章　ASP.NET MVC的精髓　103
8.1　路由传入请求　103
8.1.1　模拟ASP.NET MVC运行时　104
8.1.2　探索URL路由HTTP模块　106
8.1.3　使用应用程序路由　107
8.2　探索控制器类　113
8.2.1　了解控制器的各个方面　113
8.2.2　编写控制器类　115
8.3　处理输入数据　119
8.3.1　手动参数绑定　119
8.3.2　模型绑定　120
8.4　产生操作结果　124
8.4.1　包装结果　124
8.4.2　返回HTML标记内容　126
8.4.3　返回JSON内容　132
8.5　小结　133
第9章　Bootstrap的精髓　135
9.1　Bootstrap概览　135
9.1.1　LESS和Bootstrap基础　135
9.1.2　设置Bootstrap　138
9.1.3　透析Bootstrap　138
9.2　反应式布局　139
9.2.1　网格系统　139
9.2.2　基于屏幕大小的渲染　141
9.3　现今Web元素的分类体系　145
9.3.1　重塑基本HTML元素的样式　145
9.3.2　重塑列表HTML元素的样式　153
9.3.3　了解更高级的组件　155
9.4　Bootstrap扩展　161
9.4.1　自动完成　161
9.4.2　日期选择　166
9.4.3　自定义组件　168
9.5　小结　172
第　10章 ASP.NET MVC项目的组织方式　173
10.1　规划项目解决方案　173
10.1.1　把项目映射到分层架构模式　173
10.1.2　应用程序启动　175
10.1.3　研究应用程序服务　179
10.1.4　加入其他资产　181
10.1.5　创建表现布局　182
10.2　更有效地提供资源　184
10.2.1　打包　185
10.2.2　使用简化　189
10.3　研究其他方面　190
10.3.1　研究错误处理　190
10.3.2　配置用户验证　193
10.4　小结　197
第　11章 展示数据　198
11.1　组织HTML视图　198
11.1.1　探索视图模型　198
11.1.2　研究页面布局　201
11.1.3　展示视图元素　204
11.2　显示一组数据项　207
11.2.1　创建网格视图　208
11.2.2　添加页面功能　212
11.2.3　向页面元素添加滚动功能　216
11.3　添加详细视图　219
11.3.1　弹框视图　220
11.3.2　向下追溯视图　222
11.4　小结　224
第　12章 编辑数据　225
12.1　用于登录页面的通用表单　225
12.1.1　展示表单　225
12.1.2　处理提交数据　227
12.2　输入表单　229
12.2.1　Post-Redirect-Get模式　229
12.2.2　表单验证　231
12.2.3　模态输入表单　239
12.3　改善用户体验的小窍门　247
12.3.1　使用日期选择器是挺好的，但……　247
12.3.2　使用自动完成而不是冗长的下拉列表　249
12.3.3　大型输入表单的其他建议　251
12.4　小结　252
第　13章 持久化和建模　253
13.1　研究不同类型的模型　253
13.1.1　持久化模型　253
13.1.2　领域模型　254
13.1.3　输入模型　256
13.1.4　视图模型　256
13.2　设计持久层　257
13.2.1　使用隐式的遗留数据模型　258
13.2.2　使用Entity Framework　259
13.2.3　仓库模式　262
13.3　多样化持久化　264
13.3.1　多样化持久化的例子　264
13.3.2　多样化持久化的代价　265
13.4　小结　267

第三部分　分析用户体验

第　14章 创建更具交互性的视图　271
14.1　暴露JSON内容　271
14.1.1　创建JSON端点　272
14.1.2　协商内容　274
14.1.3　解决跨源问题　275
14.2　设计Web API　279
14.2.1　ASP.NET Web API的目的　279
14.2.2　在ASP.NET MVC环境中的Web API　279
14.2.3　保护独立的Web API　280
14.3　拉取内容　282
14.3.1　Ajax核心　282
14.3.2　jQuery工具　285
14.3.3　把数据绑到当前DOM　287
14.4　把内容推到客户端　290
14.4.1　ASP.NET SignalR初探　290
14.4.2　监视远程任务　291
14.4.3　ASP.NET SignalR的其他场景　294
14.5　小结　296
第　15章 反应式设计的优缺点　297
15.1　反应式Web设计的基础　297
15.1.1　RWD简史　297
15.1.2　CSS媒体查询　298
15.1.3　RWD和设备独立性　302
15.2　使RWD适配非桌面设备　303
15.2.1　处理图像　304
15.2.2　处理字体　306
15.2.3　处理朝向　307
15.3　小结　308
第　16章 让网站对移动友好　309
16.1　让视图适配实际设备　309
16.1.1　*适合移动场景的HTML5　309
16.1.2　特性检测　312
16.1.3　客户端设备检测　313
16.1.4　展望未来　316
16.2　设备友好的图像　316
16.2.1　ImageEngine平台　316
16.2.2　自动调整图像大小　317
16.3　提供设备友好的视图　318
16.3.1　提供移动内容的*佳方式是什么　318
16.3.2　服务器端检测　319
16.4　小结　324






