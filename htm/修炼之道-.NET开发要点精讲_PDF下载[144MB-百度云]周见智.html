修炼之道-.NET开发要点精讲 PDF下载 周见智 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#730239330
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#730239330
<p>书名:修炼之道-.NET开发要点精讲</p><p>作者:周见智</p><p>页数:307</p><p>定价:¥49.0</p><p>出版社:清华大学出版社</p><p>出版日期:2015-05-01</p><p>ISBN:9787302393306</p><p><h2>本书特色</h2></p>[<p>

	　　周见智、博图轩编著的《修炼之道(.net开发要点精讲)》是一本注重实际开发、接地气的.net技术书籍。作者结合多年的开发经验，用通俗易懂的语言，深入浅出地讲解在.net实际开发工作中的实用知识点。全书分为基础篇和设计篇两大部分。在基础篇，解释了“原子操作”、“阻塞方法与非阻塞方法”、 
“框架与库”、“调用与回调”等术语，重点阐述.net开发的三大基础知识点：数据类型、对象的生命期以及委托与事件。在设计篇，主要讲解“泵”结构在一些主流框架中的应用，以及它在socket网络编程、web服务器开发等实际项目中起到的关键作用；并从软件设计模式、软件设计原则以及代码依赖3个方面，对软件架构进行了深入浅出的阐释。
　　本书适合已经入门且有一定编程经验并准备向高手迈进的.net开发者。本书同时也可作为大中专院校和.net技术培训机构的参考教材。

                                        </p>]<p><h2>作者简介</h2></p>[<p>
	　　博图轩，曾在多家互联网公司担任产品经理、程序员，有多个互联网产品运作经验。IT撰稿人，擅长网络安全、Web开发，曾在多家网站担任专栏评论员。  
</p>]<p><h2>目录</h2></p>
第1章  另辟蹊径：解读.net  1.1  前.net时代  1.2  .net的组成    1.2.1  .net中的语言    1.2.2  .net中的框架库    1.2.3  公共类型系统    1.2.4  公共语言规范    1.2.5  公共语言运行时    1.2.6  .net程序的运行流程  1.3  .net中的程序集    1.3.1  程序集与exe文件的区别    1.3.2  程序集的组成    1.3.3  程序集的特点  1.4  .net的跨平台    1.4.1  write once, run anywhere的真实现状    1.4.2  .net与java平台出现的目的    1.4.3  重新看待.net  1.5  .net平台出现的意义  1.6  本章回顾  1.7  本章思考第2章  高屋建瓴：梳理编程约定  2.1  代码中的client与server  2.2  方法与线程的关系  2.3  调用线程与当前线程  2.4  阻塞方法与非阻塞方法  2.5  ui线程与线程  2.6  原子操作  2.7  线程安全  2.8  调用与回调  2.9  托管资源与非托管资源  2.10  框架与库  2.11  面向(或基于)对象与面向(或基于)组件  2.12  接口  2.13  协议  2.14  本章回顾  2.15  本章思考第3章  编程之基础：数据类型  3.1  引用类型与值类型    3.1.1  内存分配    3.1.2  字节序    3.1.3  装箱与拆箱  3.2  对象相等判断    3.2.1  引用类型判等    3.2.2  简单值类型判等    3.2.3  复合值类型判等  3.3  赋值与复制    3.3.1  引用类型赋值    3.3.2  值类型赋值    3.3.3  传参    3.3.4  浅复制    3.3.5  深复制  3.4  对象的不可改变性    3.4.1  不可改变性定义    3.4.2  定义不可改变类型  3.5  本章回顾  3.6  本章思考第4章  物以类聚：对象也有生命  4.1  堆和栈  4.2  堆中对象的出生与死亡    4.2.1  引用和实例    4.2.2  析构方法    4.2.3  正确使用对象  4.3  管理非托管资源    4.3.1  释放非托管资源的*佳时间    4.3.2  继承与组合中的非托管资源  4.4  正确使用idisposable接口    4.4.1  dispose模式    4.4.2  对象的dispose()和close()  4.5  本章回顾  4.6  本章思考第5章  重中之重：委托与事件  5.1  什么是.net中的委托    5.1.1  委托的结构    5.1.2  委托链表    5.1.3  委托的“不可改变”特性    5.1.4  委托的作用  5.2  事件与委托的关系  5.3  使用事件编程    5.3.1  注销跟注册事件同样重要    5.3.2  多线程中使用事件    5.3.3  委托链表的分步调用    5.3.4  正确定义一个使用了事件的类  5.4  弱委托    5.4.1  强引用与弱引用    5.4.2  弱委托的定义    5.4.3  弱委托的使用场合  5.5  本章回顾  5.6  本章思考第6章  线程的升级：异步编程模型  6.1  异步编程的必要性    6.1.1  同步调用与异步调用    6.1.2  异步调用的优点  6.2  委托的异步调用    6.2.1  begininvoke与endinvoke    6.2.2  asynccallback    6.2.3  处理异步调用时的异常    6.2.4  异步调用的应用  6.3  非委托的异步调用    6.3.1  异步方法    6.3.2  filestream.beginread/filestream.beginwrite  6.4  异步编程时的注意事项  6.5  本章回顾  6.6  本章思考第7章  可复用代码：组件的来龙去脉  7.1  .net中的组件    7.1.1  组件的定义    7.1.2  windows forms中的组件    7.1.3  windows forms中的控件  7.2  容器-组件-服务模型    7.2.1  容器的另类定义    7.2.2  容器与组件的合作    7.2.3  窗体设计器  7.3  设计时与运行时    7.3.1  组件的设计时与运行时    7.3.2  区分组件的当前状态    7.3.3  组件状态的应用  7.4  控件    7.4.1  控件基类    7.4.2  用户自定义控件  7.5  本章回顾  7.6  本章思考第8章  经典重视：桌面gui框架揭秘  8.1  了解传统win32应用程序的必要性  8.2  win32应用程序的结构    8.2.1  运行平台决定程序结构    8.2.2  windows消息循环    8.2.3  窗口过程    8.2.4  创建基于win32的单窗体应用程序    8.2.5  创建基于win32的多窗体应用程序  8.3  .net winform程序与传统win32程序的关联  8.4  windows forms框架  8.5  winform程序的结构    8.5.1  ui线程    8.5.2  消息循环    8.5.3  创建窗体    8.5.4  窗口过程  8.6  模式窗体与非模式窗体  8.7  本章回顾  8.8  本章思考第9章  沟通无碍：网络编程  9.1  两种socket通信方式    9.1.1  ip与端口    9.1.2  基于连接的tcp通信    9.1.3  基于无连接的udp通信    9.1.4  应用层协议    9.1.5  .net中socket编程的    相关类型  9.2  tcp通信的实现    9.2.1  定义tcp通信应用层协议    9.2.2  编写tcp通信服务端    9.2.3  编写tcp通信客户端  9.3  udp通信的实现    9.3.1  定义udp通信应用层协议    9.3.2  编写udp通信客户端  9.4  异步编程在网络编程中的应用    9.4.1  异步发送数据    9.4.2  异步实现“泵”结构  9.5  本章回顾  9.6  本章思考第10章  动力之源：  代码中的“泵”  10.1  “泵”的概念    10.1.1  现实生活中的“泵”    10.1.2  代码中的“泵”    10.1.3  代码中“泵”的作用  10.2  常见的“泵”结构    10.2.1  桌面gui框架中的“泵”    10.2.2  socket通信中的“泵”    10.2.3  web服务器中的“泵”  10.3  “泵”对框架的意义    10.3.1  重新回到框架定义    10.3.2  框架离不开“泵”  10.4  本章回顾  10.5  本章思考第11章  规绳矩墨：模式与原则  11.1  软件的设计模式    11.1.1  观察者模式    11.1.2  windows forms中的观察者模式    11.1.3  设计模式分类  11.2  软件的设计原则    11.2.1  solid原则概述    11.2.2  单一职责原则    11.2.3  开闭原则    11.2.4  里氏替换原则    11.2.5  接口隔离原则    11.2.6  依赖倒置原则  11.3  设计模式与设计原则对框架的意义  11.4  本章回顾  11.5  本章思考第12章  难免的尴尬：代码依赖  12.1  从面向对象开始    12.1.1  对象基础：封装    12.1.2  对象扩展：继承    12.1.3  对象行为：多态  12.2  不可避免的代码依赖    12.2.1  依赖存在的原因    12.2.2  耦合与内聚    12.2.3  依赖造成的“尴尬”  12.3  降低代码依赖    12.3.1  认识“抽象”与“具体”    12.3.2  再看“依赖倒置原则”    12.3.3  依赖注入  12.4  框架的“代码依赖”    12.4.1  控制转换    12.4.2  依赖注入对框架的意义  12.5  本章回顾  12.6  本章思考
