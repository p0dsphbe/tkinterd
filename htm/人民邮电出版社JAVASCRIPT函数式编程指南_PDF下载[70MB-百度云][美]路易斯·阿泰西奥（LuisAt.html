人民邮电出版社JAVASCRIPT函数式编程指南 PDF下载 [美]路易斯·阿泰西奥（LuisAt 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711546204
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711546204
<p>书名:人民邮电出版社JAVASCRIPT函数式编程指南</p><p>作者:[美] 路易斯·阿泰西奥（Luis At</p><p>页数:210</p><p>定价:¥59.0</p><p>出版社:人民邮电出版社</p><p>出版日期:2017-06-01</p><p>ISBN:9787115462046</p><p><h2>本书特色</h2></p>[<p>
本书主要介绍如何通过ECMAScript 6将函数式编程技术应用于代码，以降低代码的复杂性。
本书共三部分内容。*部分“函数式思想”是为第二部分的学习作铺垫的，这一部分引入了对函数式JavaScript的描述，从一些核心的函数式概念入手，介绍了纯函数、副作用以及声明式编程等函数式编程的主要支柱：第二部分“函数式基础”重点介绍函数式编程的核心技术，如函数链、柯里化、组合、Monad等；第三部分“函数式技能提升”则是介绍使用函数式编程解决现实问题的方法。
本书循序渐进地将函数式编程的相关知识铺陈开来，以理论作铺垫，并铺以实例，旨在帮助读者更好地掌握这些内容。如果读者是对面向对象软件有一定的了解，且对现代Web应用程序挑战有一定认识的JavaScript开发人员，那么可以从中提升函数式编程技能。如果读者是函数式编程的初学者，那么可以将本书作为入门书籍仔细阅读，为今后的学习夯实基础。
                                        </p>]<p><h2>内容简介</h2></p>[<p>本书主要介绍如何通过ECMAScript 6将函数式编程技术应用于代码，以降低代码的复杂性。本书共三部分内容。靠前部分“函数式思想”是为第二部分的学习作铺垫的，这一部分引入了对函数式JavaScript的描述，从一些核心的函数式概念入手，介绍了纯函数、副作用以及声明式编程等函数式编程的主要支柱：第二部分“函数式基础”重点介绍函数式编程的核心技术，如函数链、柯里化、组合、Monad等；第三部分“函数式技能提升”则是介绍使用函数式编程解决现实问题的方法。本书循序渐进地将函数式编程的相关知识铺陈开来，以理论作铺垫，并铺以实例，旨在帮助读者更好地掌握这些内容。如果读者是对面向对象软件有一定的了解，且对现代Web应用程序挑战有一定认识的JavaScript开发人员，那么可以从中提升函数式编程技能。如果读者是函数式编程的初学者，那么可以将本书作为入门书籍仔细阅读，为今后的学习夯实基础。</p>]<p><h2>作者简介</h2></p>[<p>Luis Atencio（@luijar）是美国佛罗里达州劳德代尔堡的Citrix Systems公司的一名软件工程师。他拥有计算机科学学士学位和硕士学位，现在使用JavaScript、Java和PHP平台进行全职开发和构建应用程序。Luis积极参与社区活动，并经常在当地的聚会和会议中发表演讲。他在luisatencio.net上发布关于软件工程的博客，并为杂志和DZone撰写文章，同时还是《RxJS in Action》的共同作者。</p>]<p><h2>目录</h2></p>
    目录
第　一部分 函数式思想

第　1章 走近函数式　3
1.1　函数式编程有用吗？　4
1.2　什么是函数式编程？　5
1.2.1　函数式编程是声明式
编程　7
1.2.2　副作用带来的问题和
纯函数　8
1.2.3　引用透明和可置换性　12
1.2.4　存储不可变数据　13
1.3　函数式编程的优点　14
1.3.1　鼓励复杂任务的分解　15
1.3.2　使用流式链来处理数据　16
1.3.3　复杂异步应用中的响应　18
1.4　总结　19
第　2章 高阶JavaScript　21
2.1　为什么要使用
JavaScript？　22
2.2　函数式与面向对象的程序设计　22
2.2.1　管理JavaScript对象的
状态　28
2.2.2　将对象视为数值　29
2.2.3　深冻结可变部分　31
2.2.4　使用Lenses定位并修改对象图　33
2.3　函数　34
2.3.1　一等函数　35
2.3.2　高阶函数　36
2.3.3　函数调用的类型　38
2.3.4　函数方法　39
2.4　闭包和作用域　40
2.4.1　全局作用域　42
2.4.2　函数作用域　43
2.4.3　伪块作用域　44
2.4.4　闭包的实际应用　45
2.5　总结　48

第二部分　函数式基础

第3章　轻数据结构，重操作　51
3.1　理解程序的控制流　52
3.2　链接方法　53
3.3　函数链　54
3.3.1　了解 lambda 表达式　54
3.3.2　用_.map做数据变换　56
3.3.3　用_.reduce 收集结果　57
3.3.4　用_.filter 删除不需要的
元素　61
3.4　代码推理　62
3.4.1　声明式惰性计算函数链　63
3.4.2　类SQL的数据：函数即
数据　66
3.5　学会递归地思考　68
3.5.1　什么是递归？　68
3.5.2　学会递归地思考　68
3.5.3　递归定义的数据结构　70
3.6　总结　73
第4章　模块化且可重用的
代码　75
4.1　方法链与函数管道的
比较　76
4.1.1　方法链接　77
4.1.2　函数的管道化　78
4.2　管道函数的兼容条件　78
4.2.1　函数的类型兼容条件　78
4.2.2　函数与元数：元组的
应用　79
4.3　柯里化的函数求值　82
4.3.1　仿真函数工厂　85
4.3.2　创建可重用的函数模板　86
4.4　部分应用和函数绑定　87
4.4.1　核心语言扩展　89
4.4.2　延迟函数绑定　89
4.5　组合函数管道　90
4.5.1　HTML部件的组合　91
4.5.2　函数组合：描述与求值
分离　92
4.5.3　函数式库的组合　95
4.5.4　应对纯的代码和不纯的
代码　96
4.5.5　point-free编程　98
4.6　使用函数组合子来管理
程序的控制流　99
4.6.1　identity（I-combinator）　99
4.6.2　tap（K-组合子）　99
4.6.3　alt（OR-组合子）　100
4.6.4　seq（S-组合子）　101
4.6.5　fork（join）组合子　101
4.7　总结　102
第5章　针对复杂应用的设计
模式　103
5.1　命令式错误处理的
不足　104
5.1.1　用try-catch处理错误　104
5.1.2　函数式程序不应抛出
异常　105
5.1.3　空值（null）检查问题　106
5.2　一种更好的解决方案
——Functor　106
5.2.1　包裹不安全的值　107
5.2.2　Functor定义　108
5.3　使用Monad函数式地处理错误　111
5.3.1　Monad：从控制流到
数据流　111
5.3.2　使用Maybe Monad和Either Monad来处理异常　115
5.3.3　使用IO Monad与外部资源交互　123
5.4　Monadic链式调用及
组合　126
5.5　总结　131

第三部分　函数式技能提升

第6章　坚不可摧的代码　135
6.1　函数式编程对单元测试的影响　136
6.2　测试命令式代码的
困难　137
6.2.1　难以识别和分解任务　137
6.2.2　对共享资源的依赖会导致结果不一致　138
6.2.3　按预定义顺序执行　139
6.3　测试函数式代码　140
6.3.1　把函数当作黑盒子　140
6.3.2　专注于业务逻辑，而不是控制流　141
6.3.3　使用Monadic式从不纯的代码中分离出纯函数　142
6.3.4　mock外部依赖　144
6.4　通过属性测试制定规格
说明　146
6.5　通过代码覆盖率衡量有
效性　152
6.5.1　衡量函数式代码测试的
有效性　152
6.5.2　衡量函数式代码的
复杂性　155
6.6　总结　158
第7章　函数式优化　159
7.1　函数执行机制　160
7.1.1　柯里化与函数上下文
堆栈　161
7.1.2　递归的弱点　164
7.2　使用惰性求值推迟
执行　165
7.2.1　使用函数式组合子避免重复计算　167
7.2.2　利用shortcut fusion　167
7.3　实现需要时调用的
策略　168
7.3.1　理解记忆化　169
7.3.2　记忆化计算密集型
函数　169
7.3.3　有效利用柯里化与
记忆化　172
7.3.4　通过分解来实现更大程度
的记忆化　173
7.3.5　记忆化递归调用　173
7.4　递归和尾递归优化　175
7.5　总结　178
第8章　管理异步事件以及
数据　181
8.1　异步代码的挑战　182
8.1.1　在函数之间创建时间依赖
关系　182
8.1.2　陷入回调金字塔　183
8.1.3　使用持续传递式样　186
8.2　一等公民Promise　188
8.2.1　链接将来的方法　190
8.2.2　组合同步和异步行为　195
8.3　生成惰性数据　197
8.3.1　生成器与递归　199
8.3.2　迭代器协议　200
8.4　使用RxJS进行函数式和响应式编程　202
8.4.1　数据作为Observable
序列　202
8.4.2　函数式编程与响应式
编程　203
8.4.3　RxJS和Promise　205
8.5　总结　206
附录　本书中使用的
JavaScript库　207
函数式JavaScript库　207
使用的其他库　208



