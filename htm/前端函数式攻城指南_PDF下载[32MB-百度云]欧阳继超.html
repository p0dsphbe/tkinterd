前端函数式攻城指南 PDF下载 欧阳继超 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#712129724
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#712129724
<p>书名:前端函数式攻城指南</p><p>作者:欧阳继超</p><p>页数:192</p><p>定价:¥59.0</p><p>出版社:电子工业出版社</p><p>出版日期:2016-10-01</p><p>ISBN:9787121297243</p><p><h2>相关资料</h2></p>[<p>作为 Ramda.js 的作者之一，我非常喜欢 Braithwaite 的《JavaScript Allonge》,喜欢 Fogus 的《Functional JavaScript》，我非常激动又有一本关于JavaScript的函数式书籍，希望尽快能见到这本书的英文版。
—— CrossEye</p>]<p><h2>本书特色</h2></p>[<p>
在后端，函数式语言层出不穷。在前端，函数式*后的边界也已经被渐渐打破。Scala的Scala.js、Clojure的ClojureScript都试图同构移向前端。然而，原生JavaScript其实也可以通过丰富的库让前端的函数式编程一样的舒适和优雅。本书涵盖了大部分函数式编程思想，包括JavaScript的函数式支持，Clojure风格的集合、递归、函数组合、宏、模式匹配、实用的Monads，以及前端的并发编程。本书适合想要了解函数式编程的JavaScript程序员或者想学习JavaScript的函数式程序员阅读。
                                        </p>]<p><h2>内容简介</h2></p>[<p>1、涵盖大部分函数式编程思想<br/>2、幽默风趣，通俗易懂<br/>3、是Clojure风格的JavaScript<br/>4、用JavaScript实现了很多奇技淫巧<br/>5、所有开发者都可以在本书中找到一些启发<br/>
</p>]<p><h2>作者简介</h2></p>[<p>欧阳继超，ThoughtWorks高级咨询师，活跃开源贡献者(github.com/jcouyang)，热爱编程与写作，译有《函数式JavaScript》以及若干开源书籍与文档。</p>]<p><h2>目录</h2></p>
    第1章　函数式JavaScript	11.1　JavaScript也是函数式语言吗	11.1.1　编程范式	11.1.2  JavaScript的函数式支持	31.2　作为函数式语言，JavaScript还差些什么	101.2.1  不可变数据结构	111.2.2  惰性求值	111.2.3  函数组合	121.2.4  尾递归优化	131.3  Underscore你错了	141.3.1  跟大家都不一样的 map 函数	141.3.2　ClojureScript	161.3.3　Mori	171.4  小结	18第1章　函数式JavaScript	11.1　JavaScript也是函数式语言吗	11.1.1　编程范式	11.1.2  JavaScript的函数式支持	31.2　作为函数式语言，JavaScript还差些什么	101.2.1  不可变数据结构	111.2.2  惰性求值	111.2.3  函数组合	121.2.4  尾递归优化	131.3  Underscore你错了	141.3.1  跟大家都不一样的 map 函数	141.3.2　ClojureScript	161.3.3　Mori	171.4  小结	18第2章　集合	192.1　集合的使用	202.1.1　向量（vector）	202.1.2　Map	232.1.3　函数组合子	242.2　持久性数据结构	272.2.1　向量的持久性数据结构	282.2.2　*后一片叶子不完整	312.2.3　所有叶子完整且叶子个数不大于完全树的叶子个数	322.2.4　所有叶子完整且叶子个数大于完全树的叶子个数	342.3　不可变性	352.3.1　致命魔术	362.3.2　引用透明性	382.3.3　函数式React	402.3.4　线程不安全	422.4　惰性序列	442.4.1　改良奥利奥吃法	442.4.2　惰性求值与及早求值	462.4.3　惰性求值的实现	482.5　小结	50第3章　递归	513.1　不可变性与递归	513.1.1　真的需要循环吗	523.1.2　递归还是循环	543.2　柯里悖论	553.2.1　Y组合子	573.2.2　栈是多么容易爆	603.3　尾递归优化	623.4　蹦跳乐园（Trampoline）	643.4.1　有穷状态机（DFA）	653.4.2　Trampoline	673.5　小结	69第4章　函数组合	704.1　Underscore到底做错了什么	704.1.1　自由（Free）变量与约束（Bound）变量	724.1.2　闭包	744.2　柯里化有什么用	754.3　Transducer	784.3.1　Reducer	794.3.2　来看看更好更快的解法	794.3.3　Reducer	804.3.4　Reducible	814.3.5　Transducer详解	824.3.6　跟柯里化有什么区别	834.4　组合与管道	844.4.1　管道（Pipeline）	844.4.2　组合与管道	864.4.3　管道函数	874.5　小结	87第5章　Macro宏	895.1　什么是REPL	895.1.1　宏扩展器（Macro Expander）	905.1.2　那么前端怎么办	925.2　为什么要语法糖	935.2.1　只是为了语法漂亮吗	945.3　Sweet.js	945.3.1　Rule Macro	955.3.2　Case Macro	975.4　Infix Macro 和 Operator	1045.4.1　Infix Macro	1045.4.2　自定义操作符	1055.5　小结	106第6章　模式匹配	1076.1　Destructure	1076.1.1　对象	1096.1.2　数组	1096.1.3　函数	1096.2　Arity 函数	1106.3　Fizz Buzz	1116.3.1　字面匹配（Literal Matching）	1116.3.2　绑定	1136.3.3　Vector与Map匹配	1136.3.4　Guard	1146.3.5　Sparkler	1146.4　代数数据类型（ADT）	1166.5　小结	118第7章　Monadic编程	1197.1　链式调用	1197.1.1　Promise	1207.1.2　高阶Promise	1227.2　Monad	1237.2.1　函子（Functor）	1237.2.2　Applicative Functor	1267.2.3　含幺半群（Monoid）	1307.2.4　Monad就是容器界的管道	1327.2.5　Monad就是自函子范畴上的一个幺半群	1367.3　走钢丝	1397.3.1　用Monad表示薛定谔猫	1397.3.2　皮尔斯走钢丝	1407.4　Monad在JavaScript中的应用	1437.4.1　Promise版本的走钢丝	1447.4.2　When	1447.5　Reactive编程	1467.5.1　流（Stream）	1467.5.2　Functor	1477.5.3　Applicative	1477.5.4　Monad	1487.5.5　一个“简单”的Reactive实例	1497.6　小结	153第8章　并发编程	1548.1　什么是并发	1548.1.1　异步与多线程	1558.1.2　JavaScript的并发模型	1578.2　通信顺序进程（CSP）	1608.3　使用Generator实现CSP	1628.3.1　Generator	1638.3.2　Go Block	1638.3.3　timeout	1648.3.4　take ＜!	1658.3.5　put ＞!	1658.3.6　JavaScript CSP版本的例子	1668.4　实战 CSP	1688.4.1　使用移植的core.async	1688.4.2　使用ES7中的异步函数	1698.4.3　try catch	1708.5　小结	173参考资料	174信息
